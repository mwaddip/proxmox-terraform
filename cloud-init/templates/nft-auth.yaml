#cloud-config
# NFT Authentication Cloud-Init Template
# Variables (substituted by vm-generator.py):
#   ${VM_NAME}         - VM hostname
#   ${VM_IP}           - Allocated IP address
#   ${USERNAME}        - Linux username
#   ${NFT_TOKEN_ID}    - Reserved NFT token ID
#   ${CHAIN_ID}        - Blockchain chain ID
#   ${NFT_CONTRACT}    - NFT contract address
#   ${RPC_URL}         - JSON-RPC endpoint URL
#   ${OTP_LENGTH}      - OTP code length
#   ${OTP_TTL}         - OTP time-to-live in seconds

users:
  - name: ${USERNAME}
    gecos: "nft=${NFT_TOKEN_ID}"
    groups: sudo
    shell: /bin/bash
    sudo: ALL=(ALL) NOPASSWD:ALL
    ssh_authorized_keys: ${SSH_KEYS}

write_files:
  - path: /etc/pam_web3/config.toml
    permissions: '0640'
    content: |
      [machine]
      id = "${VM_NAME}"
      private_key_file = "/etc/pam_web3/server.key"

      [auth]
      mode = "nft"
      nft_lookup = "passwd"
      signing_url = "http://${VM_IP}:8080"
      otp_length = ${OTP_LENGTH}
      otp_ttl_seconds = ${OTP_TTL}

      [blockchain]
      socket_path = "/run/web3-auth/web3-auth.sock"
      chain_id = ${CHAIN_ID}
      nft_contract = "${NFT_CONTRACT}"
      timeout_seconds = 10

  - path: /etc/web3-auth/config.toml
    permissions: '0640'
    content: |
      socket_path = "/run/web3-auth/web3-auth.sock"
      backend = "jsonrpc"
      default_chain_id = ${CHAIN_ID}
      default_contract = "${NFT_CONTRACT}"

      [jsonrpc]
      rpc_url = "${RPC_URL}"
      timeout_seconds = 30

  - path: /etc/pam.d/sshd
    content: |
      # Web3 NFT authentication for all users
      auth [success=done default=die] pam_web3.so

      # Standard account/session management
      account    required     pam_nologin.so
      @include common-account
      session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so close
      session    required     pam_loginuid.so
      session    optional     pam_keyinit.so force revoke
      @include common-session
      session    optional     pam_motd.so  motd=/run/motd.dynamic
      session    optional     pam_motd.so noupdate
      session    optional     pam_mail.so standard noenv
      session    required     pam_limits.so
      session    required     pam_env.so
      session    required     pam_env.so user_readenv=1 envfile=/etc/default/locale
      session [success=ok ignore=ignore module_unknown=ignore default=bad] pam_selinux.so open
      @include common-password

  - path: /usr/local/bin/wait-for-nft.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Wait for NFT to be minted before starting the signing page
      # The NFT is minted AFTER terraform apply succeeds, so there's a race condition

      CONTRACT="${NFT_CONTRACT}"
      RPC_URL="${RPC_URL}"
      TOKEN_ID="${NFT_TOKEN_ID}"
      TIMEOUT=300  # 5 minutes
      INTERVAL=5   # Check every 5 seconds

      echo "Waiting for NFT #$TOKEN_ID to be minted on contract $CONTRACT..."

      # Convert token ID to hex (padded to 32 bytes)
      TOKEN_HEX=$(printf '%064x' "$TOKEN_ID")

      # ownerOf(uint256) function selector: 0x6352211e
      CALL_DATA="0x6352211e$TOKEN_HEX"

      check_nft_exists() {
          # Use cast if available (faster, cleaner output)
          if command -v cast &>/dev/null; then
              cast call "$CONTRACT" "ownerOf(uint256)(address)" "$TOKEN_ID" --rpc-url "$RPC_URL" 2>/dev/null
              return $?
          fi

          # Fallback to curl with JSON-RPC
          response=$(curl -s -X POST "$RPC_URL" \
              -H "Content-Type: application/json" \
              -d "{\"jsonrpc\":\"2.0\",\"method\":\"eth_call\",\"params\":[{\"to\":\"$CONTRACT\",\"data\":\"$CALL_DATA\"},\"latest\"],\"id\":1}")

          # Check if response contains an error (token doesn't exist = revert)
          if echo "$response" | grep -q '"error"'; then
              return 1
          fi

          # Check if result is a valid address (not 0x or empty)
          result=$(echo "$response" | grep -o '"result":"[^"]*"' | cut -d'"' -f4)
          if [ -z "$result" ] || [ "$result" = "0x" ]; then
              return 1
          fi

          return 0
      }

      start_time=$(date +%s)
      while true; do
          if check_nft_exists; then
              echo "NFT #$TOKEN_ID found!"
              exit 0
          fi

          # Check timeout
          current_time=$(date +%s)
          elapsed=$((current_time - start_time))
          if [ $elapsed -ge $TIMEOUT ]; then
              echo "Timeout waiting for NFT #$TOKEN_ID after ${TIMEOUT}s"
              exit 1
          fi

          echo "NFT not found yet, retrying in ${INTERVAL}s... (${elapsed}s elapsed)"
          sleep $INTERVAL
      done

  - path: /etc/systemd/system/web3-sign.service
    content: |
      [Unit]
      Description=Web3 Signing Page HTTP Server
      After=network.target

      [Service]
      Type=simple
      ExecStartPre=/usr/local/bin/wait-for-nft.sh
      ExecStart=/usr/share/libpam-web3/scripts/extract-signing-page.sh --contract ${NFT_CONTRACT} --rpc-url ${RPC_URL} --token-id ${NFT_TOKEN_ID} --port 8080 --no-browser
      Restart=on-failure
      RestartSec=30

      [Install]
      WantedBy=multi-user.target

  - path: /etc/ssh/sshd_config.d/web3-auth.conf
    content: |
      ChallengeResponseAuthentication yes
      UsePAM yes

runcmd:
  # Generate machine keypair
  - pam_web3_tool generate-keypair --output /etc/pam_web3/server.key
  - chmod 600 /etc/pam_web3/server.key

  # Start services
  - systemctl daemon-reload
  - systemctl enable --now web3-auth-svc
  - systemctl enable --now web3-sign
  - systemctl restart sshd

final_message: "Web3 NFT authentication configured after $UPTIME seconds"
